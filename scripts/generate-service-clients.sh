#!/usr/bin/env bash
#
# generate-service-clients.sh
# Aggregates metadata from all microservices and generates the centralized service_clients.go
#

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
PKG_GRPC_DIR="$PROJECT_ROOT/pkg/grpc"
METADATA_DIR="$PKG_GRPC_DIR/metadata"
OUTPUT_FILE="$PKG_GRPC_DIR/service_clients.go"

echo "ðŸ” Scanning for microservice metadata..."

# Check if metadata directory exists
if [ ! -d "$METADATA_DIR" ]; then
    echo "âŒ Metadata directory not found: $METADATA_DIR"
    echo "   Please run 'make generate-grpc' for each microservice first"
    exit 1
fi

# Find all metadata JSON files
METADATA_FILES=$(find "$METADATA_DIR" -name "*_services.json" -type f)

if [ -z "$METADATA_FILES" ]; then
    echo "âŒ No metadata files found in $METADATA_DIR"
    echo "   Please run 'make generate-grpc' for each microservice first"
    exit 1
fi

# Extract unique microservices
MICROSERVICES=()
for file in $METADATA_FILES; do
    basename=$(basename "$file" "_services.json")
    MICROSERVICES+=("$basename")
done

echo "âœ… Found ${#MICROSERVICES[@]} microservices: ${MICROSERVICES[*]}"

# Generate service_clients.go
echo "ðŸ“ Generating $OUTPUT_FILE..."

cat > "$OUTPUT_FILE" << 'EOF'
package grpc

import (
	"sync"
)

// ServiceClients provides lazy-initialized clients for each microservice
// One client per microservice (not per model)
//
// This file is auto-generated by scripts/generate-service-clients.sh
// DO NOT EDIT MANUALLY - run 'make generate-clients' to regenerate
type ServiceClients struct {
	gatewayClient *GatewayClient

EOF

# Add client fields for each microservice
for service in "${MICROSERVICES[@]}"; do
    # Capitalize first letter for type name
    service_title="$(tr '[:lower:]' '[:upper:]' <<< ${service:0:1})${service:1}"

    cat >> "$OUTPUT_FILE" << EOF
	// ${service_title} microservice client
	${service}Client     *${service_title}ServiceClient
	${service}ClientOnce sync.Once

EOF
done

# Add constructor
cat >> "$OUTPUT_FILE" << 'EOF'
}

// NewServiceClients creates a new service clients instance
func NewServiceClients(gatewayClient *GatewayClient) *ServiceClients {
	return &ServiceClients{
		gatewayClient: gatewayClient,
	}
}

EOF

# Add getter methods for each microservice
for service in "${MICROSERVICES[@]}"; do
    # Capitalize first letter for type name
    service_title="$(tr '[:lower:]' '[:upper:]' <<< ${service:0:1})${service:1}"

    cat >> "$OUTPUT_FILE" << EOF
// ${service_title} returns the ${service_title} microservice client (handles all ${service} models)
func (s *ServiceClients) ${service_title}() *${service_title}ServiceClient {
	s.${service}ClientOnce.Do(func() {
		s.${service}Client = New${service_title}ServiceClient(s.gatewayClient)
	})
	return s.${service}Client
}

EOF
done

# Add legacy compatibility
cat >> "$OUTPUT_FILE" << 'EOF'
// Legacy compatibility - will be deprecated
type AutoClients = ServiceClients

// NewAutoClients is deprecated, use NewServiceClients instead
func NewAutoClients(gatewayClient *GatewayClient) *AutoClients {
	return NewServiceClients(gatewayClient)
}
EOF

echo "âœ… Generated $OUTPUT_FILE"

# Format the file
if command -v gofmt &> /dev/null; then
    echo "ðŸŽ¨ Formatting with gofmt..."
    gofmt -w "$OUTPUT_FILE"
fi

# Print summary
echo ""
echo "ðŸ“Š Summary:"
echo "   Microservices: ${#MICROSERVICES[@]}"
for service in "${MICROSERVICES[@]}"; do
    service_title="$(tr '[:lower:]' '[:upper:]' <<< ${service:0:1})${service:1}"
    metadata_file="$METADATA_DIR/${service}_services.json"
    entity_count=$(jq 'length' "$metadata_file" 2>/dev/null || echo "?")
    echo "   - $service_title: $entity_count models"
done

echo ""
echo "âœ¨ Service clients generation complete!"
echo "   Usage: r.Services().Auth().GetUserByID(ctx, id)"

