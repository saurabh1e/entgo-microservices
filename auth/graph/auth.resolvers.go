package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"
	"strings"

	"github.com/saurabh/entgo-microservices/auth/graph/model"
	"github.com/saurabh/entgo-microservices/auth/internal/ent"
	"github.com/saurabh/entgo-microservices/auth/internal/ent/user"
	"github.com/saurabh/entgo-microservices/pkg/authz"
	pkgcache "github.com/saurabh/entgo-microservices/pkg/cache"
	pkgcontext "github.com/saurabh/entgo-microservices/pkg/context"
	"github.com/saurabh/entgo-microservices/pkg/jwt"
	"github.com/saurabh/entgo-microservices/pkg/logger"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.LoginResponse, error) {
	ctx = authz.SetBypass(ctx, true)

	// Find user by email or username
	userEntity, err := r.client.User.Query().
		Where(user.Or(user.Email(input.Email), user.Username(input.Email))).
		Only(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, fmt.Errorf("invalid credentials")
		}
		logger.WithError(err).Error("Failed to query user during login")
		return nil, fmt.Errorf("login failed")
	}

	if !userEntity.IsActive {
		return nil, fmt.Errorf("account is deactivated")
	}

	// Hash password if needed and verify
	passwordHash, err := r.hashPasswordIfNeeded(ctx, userEntity)
	if err != nil {
		logger.WithError(err).Error("Password hash error")
		return nil, fmt.Errorf("login failed")
	}

	if !jwt.CheckPassword(input.Password, passwordHash) {
		return nil, fmt.Errorf("invalid credentials")
	}

	// Generate tokens
	accessToken, refreshToken, err := r.jwtService.GenerateTokenPair(ctx, userEntity.ID, userEntity.Username, userEntity.Email)
	if err != nil {
		logger.WithError(err).Error("Failed to generate tokens")
		return nil, fmt.Errorf("login failed")
	}

	// Cache user data asynchronously
	r.cacheUserData(userEntity)

	logger.WithFields(map[string]interface{}{"user_id": userEntity.ID, "email": userEntity.Email}).Info("User logged in")

	return &model.LoginResponse{
		User:         userEntity,
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
	}, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.RegisterResponse, error) {
	// Check if user already exists
	exists, err := r.client.User.Query().
		Where(user.Or(user.Email(input.Email), user.Username(input.Email))).
		Exist(ctx)
	if err != nil {
		logger.WithError(err).Error("Failed to check if user exists")
		return nil, fmt.Errorf("registration failed")
	}
	if exists {
		return nil, fmt.Errorf("user with this email already exists")
	}

	// Hash password and generate username
	hashedPassword, err := jwt.HashPassword(input.Password)
	if err != nil {
		logger.WithError(err).Error("Failed to hash password")
		return nil, fmt.Errorf("registration failed")
	}

	username := input.Email
	if strings.Contains(username, "@") {
		username = strings.Split(username, "@")[0]
	}

	// Create user
	userEntity, err := r.client.User.Create().
		SetEmail(input.Email).
		SetUsername(username).
		SetPasswordHash(hashedPassword).
		SetName(input.Name).
		Save(ctx)
	if err != nil {
		if ent.IsConstraintError(err) {
			return nil, fmt.Errorf("user with this email or username already exists")
		}
		logger.WithError(err).Error("Failed to create user")
		return nil, fmt.Errorf("registration failed")
	}

	// Generate tokens
	accessToken, refreshToken, err := r.jwtService.GenerateTokenPair(ctx, userEntity.ID, userEntity.Username, userEntity.Email)
	if err != nil {
		logger.WithError(err).Error("Failed to generate tokens for new user")
		return nil, fmt.Errorf("registration failed")
	}

	// Cache user data asynchronously
	r.cacheUserData(userEntity)

	logger.WithFields(map[string]interface{}{"user_id": userEntity.ID, "email": userEntity.Email}).Info("User registered")

	return &model.RegisterResponse{
		User:         userEntity,
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (*model.LogoutResponse, error) {
	tokenString, err := extractToken(ctx)
	if err != nil {
		return nil, err
	}

	// Validate token to get user ID for cache invalidation
	if claims, err := r.jwtService.ValidateToken(ctx, tokenString); err == nil && claims != nil {
		// Invalidate user cache
		if err := pkgcache.InvalidateUserCache(ctx, r.redisClient, "auth", claims.UserID); err != nil {
			logger.WithError(err).WithField("user_id", claims.UserID).Warn("Failed to invalidate user cache")
		}
	}

	// Add token to blacklist
	if err := r.jwtService.RevokeToken(ctx, tokenString); err != nil {
		logger.WithError(err).Error("Failed to revoke token during logout")
		return nil, fmt.Errorf("logout failed")
	}

	logger.Info("User logged out")

	return &model.LogoutResponse{Success: true}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context) (*model.TokenResponse, error) {
	tokenString, err := extractToken(ctx)
	if err != nil {
		return nil, err
	}

	// Validate refresh token to get user ID
	claims, err := r.jwtService.ValidateToken(ctx, tokenString)
	if err != nil {
		logger.WithError(err).Error("Failed to validate refresh token")
		return nil, fmt.Errorf("token refresh failed: %v", err)
	}

	// Generate new token pair
	accessToken, refreshToken, err := r.jwtService.RefreshAccessToken(ctx, tokenString)
	if err != nil {
		logger.WithError(err).Error("Failed to refresh token")
		return nil, fmt.Errorf("token refresh failed: %v", err)
	}

	// Refresh user cache asynchronously
	go func() {
		bgCtx := authz.SetBypass(context.Background(), true)
		if userEntity, err := r.client.User.Get(bgCtx, claims.UserID); err == nil {
			r.cacheUserData(userEntity)
		} else {
			logger.WithError(err).WithField("user_id", claims.UserID).Warn("Failed to get user for caching on token refresh")
		}
	}()

	logger.Info("Token refreshed")

	return &model.TokenResponse{
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
	}, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*ent.User, error) {
	// Get user ID from context (set by auth middleware)
	userCtx, ok := pkgcontext.GetUser(ctx)
	if !ok {
		return nil, fmt.Errorf("user not authenticated")
	}

	// Get user from database
	userEntity, err := r.client.User.Query().
		Where(user.IDEQ(userCtx.ID)).
		Only(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, fmt.Errorf("user not found")
		}
		logger.WithError(err).Error("Failed to get user for me query")
		return nil, fmt.Errorf("failed to get user information")
	}

	// Check if user is still active
	if !userEntity.IsActive {
		return nil, fmt.Errorf("account is deactivated")
	}

	return userEntity, nil
}
